<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="iOS,Swift," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="Swift 3.0 的变化">
<meta property="og:type" content="article">
<meta property="og:title" content="Swift3.0变化">
<meta property="og:url" content="http://yoursite.com/2016/07/15/Swift3-0变化/index.html">
<meta property="og:site_name" content="WillToSky">
<meta property="og:description" content="Swift 3.0 的变化">
<meta property="og:updated_time" content="2016-07-15T10:15:08.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Swift3.0变化">
<meta name="twitter:description" content="Swift 3.0 的变化">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> Swift3.0变化 | WillToSky </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?bb1aa8ec5764977520de27eaccc4124a";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta custom-logo">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">WillToSky</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">学习反思之路</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Swift3.0变化
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-07-15T18:06:05+08:00" content="2016-07-15">
              2016-07-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/iOS/Swift/" itemprop="url" rel="index">
                    <span itemprop="name">Swift</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/15/Swift3-0变化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/15/Swift3-0变化/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Swift-3-0-变化"><a href="#Swift-3-0-变化" class="headerlink" title="Swift 3.0 变化"></a>Swift 3.0 变化</h1><h2 id="删除currying-柯里化-func-定义语句"><a href="#删除currying-柯里化-func-定义语句" class="headerlink" title="删除currying(柯里化)func 定义语句"></a>删除currying(柯里化)<code>func</code> 定义语句</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>柯里化函数定义语句<code>func foo(x:Int)(y:Int)</code>是没有用的限制和制造了大量的语法和实现的复杂性。我们将删除他</p>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>柯里化方法定义存在有撞击效应，使得其他语言特征变得复杂</p>
<ul>
<li><p>柯里化方法的存在导致关键词规则和方法名的定义的混乱。我们几次辩论是否进行柯里化的参数相当于是对函数参数的延续。从新功能的参数列表或值得跟随其他完全不同的规则。</p>
</li>
<li><p>在<code>var</code>和<code>inout</code>参数解析中有精妙交互。在任何地方，一个拥有<code>input</code>参数的柯里化函数，它的第一个分句不能被部分应用而没有意想不到的语义限制，这限制它的实用性。对于<code>var</code>参数，有个问题是关于<code>var</code>获取范围的等级设定，许多使用者期望在应用最外面的部分，但我们当前绑定的在应用的最里面部分。</p>
</li>
</ul>
<p>在基础库，Cocoa和大部分第三方代码中没有真正使用<code>ML-style</code>说法去柯里化有利的自由函数。在Cocoa和基础库中，大部分的函数，他们依然能有效部分程序通过<code>self.method</code>和可能有一天会用到<code>map.{f($0)}</code>一样。柯里化函数的设计早于关键词理论模型设计。我们已经计划离开<code>arguments-are-a-single-tuple</code>模型，这将使我们的特性离开<code>ML-argument</code>模型</p>
<p>许多使用者已经察觉到柯里化特征的无用性，并且要求<code>Scala-style f(_,1)</code>自由形式部分应用作为代替。现实是许多熟悉功能的使用者没有看出柯里化特征的价值让我们觉得好像我妈不使用它可能会更好，这确实是“如果我们不是已经拥有它我们将添加”的失败尝试。</p>
<h3 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h3><p>我们删除支持在<code>func</code>定义时多参数模式的支持。降低语法从<code>func-signature</code>到仅仅允许一个参数条款。为了兼容的目的，已经存在的使用柯里化定义语法的代码能被转化为明确返回一个闭包作为代替：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Before</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">curried</span><span class="params">(x:Int)</span></span>(y:<span class="type">String</span>) -&gt; <span class="type">Float</span></div><div class="line">&#123;</div><div class="line"> <span class="keyword">return</span> <span class="type">Float</span>(x) + <span class="type">Float</span>(y)!</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// After</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">curried</span><span class="params">(x:Int)</span></span> -&gt;(<span class="type">String</span>)-&gt;<span class="type">Float</span>&#123;</div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		(y:<span class="type">String</span>)-&gt;<span class="type">Float</span> <span class="keyword">in</span></div><div class="line">		<span class="keyword">return</span> <span class="type">Float</span>(x) + <span class="type">Float</span>(y)!</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我没有提议改变函数的语法，这保存了<code>Self -&gt; Args -&gt; Return</code>类型的函数</p>
<h3 id="存在代码的影响"><a href="#存在代码的影响" class="headerlink" title="存在代码的影响"></a>存在代码的影响</h3><p>这次删除了一个语言特性，者将明显破坏已存在的使用者特性的代码。我们任认为柯里化是非常小的功能，反对新出现的语言实践，和这是一个明智的自动的转移。所有为了简化语言这是个可接受的影响</p>
<h3 id="可选择的考虑"><a href="#可选择的考虑" class="headerlink" title="可选择的考虑"></a>可选择的考虑</h3><p>可选择的去保护我们上面讨论的柯里化不是一个好的主意。及时我们没有提出任何迫切行动，但未来可选择设计去提供更相似的功能设计额主要符合语法习惯的方法包括：</p>
<ul>
<li>Scala-like 和 ad-hoc 部分应用语法，例如有些类似<code>foo(_,bar:2)</code>可能会被简写成<code>{x in foo(x，bar:2)}</code>。这已经可论证有利于我们关键字-参数-熟悉API设计的可读性，和比转化柯里化更加灵活，这要求请求参数顺序被API的设计者预先排序。</li>
<li>方法 and/or 算子切片算法。我们有<code>self.method</code>去部分绑定一个方法到我们他的<code>non-self</code>参数，这对高级排序耗时像<code>map</code>和<code>filter</code>特别有用。Haskell像<code>(2+)</code>/<code>(+2)</code>语法对于正在应用的算子可能更好。</li>
</ul>
<h2 id="删除函数参数中的var"><a href="#删除函数参数中的var" class="headerlink" title="删除函数参数中的var"></a>删除函数参数中的<code>var</code></h2><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>这次建议从原始格式中接受一些重要改变。看这文档的结尾关于历史信息和建议改变的原因。</p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>但参数用<code>inout</code>和<code>var</code>标志时会有一些迷惑。这两个都给一个值的可变复制但被<code>inout</code>标识的会自动回写。<br>函数参数默认情况是不可改变的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(i: Int)</span></span>&#123;</div><div class="line">	i += <span class="number">1</span>;<span class="comment">// 不允许</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(<span class="keyword">var</span> i:Int)</span></span>&#123;</div><div class="line">	i += ; <span class="comment">//可以，但是调用者不能到这个改变</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，本地复制的<code>x</code>已经改变，但这个写入不会被传回到已经传入的原始值，所以调用者不能直接观察到这个改变。为了法相值得类型，你必须用<code>input</code>标记参数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomethingWithVar</span><span class="params">(<span class="keyword">var</span> i: Int)</span></span> &#123;</div><div class="line">  i = <span class="number">2</span> <span class="comment">// i可以被修改，但不会影响调用者传入的值</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomethingWithInout</span><span class="params">(<span class="keyword">inout</span> i: Int)</span></span> &#123;</div><div class="line">  i = <span class="number">2</span> <span class="comment">// i可以被修改，会影响调用者传入的值</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> x = <span class="number">1</span></div><div class="line"><span class="built_in">print</span>(x) <span class="comment">// 1</span></div><div class="line"></div><div class="line">doSomethingWithVar(x)</div><div class="line"><span class="built_in">print</span>(x) <span class="comment">// 1</span></div><div class="line"></div><div class="line">doSomethingWithInout(&amp;x)</div><div class="line"><span class="built_in">print</span>(x) <span class="comment">// 2</span></div></pre></td></tr></table></figure>
<h3 id="动机-1"><a href="#动机-1" class="headerlink" title="动机"></a>动机</h3><p>在函数参数使用<code>var</code>注释已经限制了实用性，为了充分利用一行代码而造成和<code>input</code>这个人们所想的有更多语义的造成迷惑。为了强调这个值是只有复制功能而没有<code>inout</code>语法的回写功能，我们应该不允许<code>var</code>在这里使用。</p>
<p>总的来说，促进这个问题的修改原因有：</p>
<ul>
<li>在函数参数中，<code>var</code>经常和<code>inout</code>混淆</li>
<li><code>var</code>经常被认为让数值拥有引用的语义</li>
<li>函数参数都是不可反驳的模式，像在 if-，while-，guard-，for-in-，和case声明</li>
</ul>
<h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>对于语法，这是个细小的改变，在Swift 2.2中，会发出过时警告。直到Swift3.0中，它将变成一个错误</p>
<h3 id="对现在代码的影响"><a href="#对现在代码的影响" class="headerlink" title="对现在代码的影响"></a>对现在代码的影响</h3><p>像远离使用<code>var</code>的纯机械迁移，一个短期的变化能立即被介绍，即对上面的所有<code>var</code>的使用，复制一份可变的副本。例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(i:Int)</span></span>&#123;</div><div class="line"><span class="keyword">var</span> i = i;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而，使用副本并不是一个必要的主意，可能暗示一个反模式。我们希望Swift的使用者能重新思考下存在的代码，去适应这个语言的改变，但这不是严格必要的。</p>
<h2 id="删除-和-运算符"><a href="#删除-和-运算符" class="headerlink" title="删除 ++和--运算符"></a>删除 <code>++</code>和<code>--</code>运算符</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>在Swift开发很早的时候，我们就添加了 增加/减少运算符，是从C语言里面继承过来的。我们添加时没有考虑很多，而且从那之后也不在提起过。这个文档将提供为他们提供一个新的视角。当他们造成困惑和没有带来他们的价值时，最终，我仅仅是将他们完全删除。</p>
<p>作为一个复习，一共有4个运算符在这个家庭中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = ++x; <span class="comment">// 先进行加法，在数字变化后返回一个值</span></div><div class="line"><span class="keyword">let</span> b = x++; <span class="comment">// 先返回一个值，在进行加法运行</span></div><div class="line"><span class="keyword">let</span> <span class="built_in">c</span> = --x; <span class="comment">// 先进行减法，在数字变化后返回一个值</span></div><div class="line"><span class="keyword">let</span> d = x--; <span class="comment">// 先返回一个值，在进行减法运行</span></div></pre></td></tr></table></figure>
<p>然而，这些运算符的结果值经常被忽略</p>
<h3 id="这些运算符的有利条件"><a href="#这些运算符的有利条件" class="headerlink" title="这些运算符的有利条件"></a>这些运算符的有利条件</h3><p>这些运算符的主要有利条件是他们的表达能力。他们比在数值类型上<code>x += 1</code>更加简短，在像迭代器值上比<code>x.advance()</code>跟简洁。当需要返回值时，Swift的<code>+=</code>运算符不能被使用，因为它返回的是<code>Void</code></p>
<p>第二个有利条件是支持这个运算符家庭是与C和其他常用语言在C语言上的拓展有联系。人们从其他语言转到Swift，可能合理地期望这些运算符的存在。也就是说，其他流行语言保持大多数C的运算符，而没有丢弃它。</p>
<h3 id="这些运算符的不利条件"><a href="#这些运算符的不利条件" class="headerlink" title="这些运算符的不利条件"></a>这些运算符的不利条件</h3><ol>
<li>这些运算符增加了将Swift作为第一门学习语言，或其他一些不知道这些运算符的人的学习负担</li>
<li>他们表现的有利条件是细小的 - <code>x++</code>不比<code>x += 1</code>短多少</li>
<li>Swift在<code>=</code>，<code>+=</code>和其他返回<code>Void</code>的转换运算符已经和C有了偏离，这些运算符和这些模型相矛盾</li>
<li>Swift有许多有力的特性，这些排除了许多你为了适应其他代码而使用<code>++i</code>C风格的常见理由，所以这些在好的Swift代码中很少被使用。这些特性包括<code>for-in</code>loop，ranges，<code>enumerate</code>，<code>map</code>等</li>
<li>使用者使用这些运算符的返回值，经常使代码的阅读者/维护者产生迷惑和隐患。他们鼓励<code>过度复杂</code>的代码，这可能比较小巧玲珑，但却会造成理解困难</li>
<li>这里Swift有好的定义评估体制，任何依赖于它的将会变得不受欢迎，即使有好的定义</li>
<li>这些运算符只能使用在相对少的类型：整型和浮点型，和类似迭代器概念。他们不能适用于复制的数字，矩形等。</li>
</ol>
<h2 id="删除条件和自增的C风格的for循环"><a href="#删除条件和自增的C风格的for循环" class="headerlink" title="删除条件和自增的C风格的for循环"></a>删除条件和自增的C风格的for循环</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>C风格的for循环是机械的从C中搬运过来的，而不是真实的Swift特色结构。这个很少被使用和不是很像Swift</p>
<p>大部分的Swift类型结构以及能够获得<code>for-in</code>声明和<code>stride</code>。删除for循环将会精简语言和断绝大部分常见的<code>--</code>和<code>++</code>的使用点。<code>--</code>和<code>++</code>已经从语言中被排除</p>
<p>这种结构的价值是有限的，我认为应该严肃考虑它的删除</p>
<h3 id="for循环的优点"><a href="#for循环的优点" class="headerlink" title="for循环的优点"></a>for循环的优点</h3><p>Swift支持一种浅学习曲线，通过使用熟悉的内容和控制结构。<code>for-loop</code>模仿C和限制了掌控该控制流需要付出的努力</p>
<h3 id="for循环的缺点"><a href="#for循环的缺点" class="headerlink" title="for循环的缺点"></a>for循环的缺点</h3><ol>
<li><code>for-in</code>和<code>stride</code>使用Swift的相关方法提供了对等的行为，不应该被过去遗留的捆绑</li>
<li>直接表现的缺点在<code>for-loops</code>不如<code>for-in</code>简洁</li>
<li><code>for-loop</code>执行不借给自己去使用集合和其他核心的Swift类型</li>
<li><code>for-loop</code>鼓励使用一元自增或自减，这将要从语言中被删除</li>
<li>分号界点定义提出了一个陡峭的学习曲线，当使用者从非类C语言转化过来时</li>
</ol>
<h3 id="拟议方法"><a href="#拟议方法" class="headerlink" title="拟议方法"></a>拟议方法</h3><p>我建议for循环在Swift2.x被标过时，在Swift3.0中被删除。</p>
<h3 id="可选择的考虑-1"><a href="#可选择的考虑-1" class="headerlink" title="可选择的考虑"></a>可选择的考虑</h3><p>没有将<code>for-loop</code>从Swift中删除，将丢失一个提高语言效率和求其一个不需要控制流事件的机会</p>
<h3 id="对存在代码的影响"><a href="#对存在代码的影响" class="headerlink" title="对存在代码的影响"></a>对存在代码的影响</h3><p>一个苹果的Swift代码基础调查显示，这个特性很少被使用。Swift演变市区成员的邮件证实，在许多职业级程序中并没有这个特性，他们能正常运行当<code>for-loop</code>被移除时：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">char *blk_xor(char *dst,const char *src,size_t len)</div><div class="line">&#123;</div><div class="line">	const char *sp = src;</div><div class="line">	for (char *dp = dst; sp - src &lt; len : sp++,dp++)</div><div class="line">	*dp ^= *sp;</div><div class="line">	return dst;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相对的</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">blk_xor</span><span class="params">(dst:UnsafeMutablePointer&lt;CChar&gt;,src: UnsafePointer&lt;CChar&gt;, len:Int)</span></span> -&gt; <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">CChar</span>&gt; &#123;</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt; len&#123;</div><div class="line">		dst[i] ^= src[i]</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> dst</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个github的Swfit主旨调查显示，这儿方法被那些语言的初学者使用，而被那些精湛掌握语言的人抛弃</p>
<p>例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> <span class="keyword">var</span> i =<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</div><div class="line">	<span class="built_in">print</span>(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> array = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>]</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; array.<span class="built_in">count</span>;i++)</div><div class="line">&#123;</div><div class="line">	<span class="built_in">println</span>(<span class="string">"array[i]\(array[i])"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="为可选序列添加懒加载的flatMap"><a href="#为可选序列添加懒加载的flatMap" class="headerlink" title="为可选序列添加懒加载的flatMap"></a>为可选序列添加懒加载的flatMap</h2><h3 id="介绍-4"><a href="#介绍-4" class="headerlink" title="介绍"></a>介绍</h3><p>最近，Swift的基础库中有2个版本的<code>flatMap</code>。在转化后平滑一个序列的序列：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].flatMap&#123; n <span class="keyword">in</span> n..&lt;<span class="number">5</span>&#125;</div><div class="line"><span class="comment">//[1,2,3,4,2,3,4,3,4]</span></div></pre></td></tr></table></figure>
<p>和另一个平滑可选序列</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(1...10).flatMap&#123;n in n%2 == 0 ? n/2 : nil&#125;</div><div class="line">//[1,2,3,4,5]</div></pre></td></tr></table></figure>
<p>然而，这里只有第一种版本的懒加载实现</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="built_in">lazy</span>.flatMap(n <span class="keyword">in</span> n..&lt;<span class="number">5</span>)</div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line">(<span class="number">1</span>...<span class="number">10</span>).<span class="built_in">lazy</span>.flatMap&#123;n <span class="keyword">in</span> n%<span class="number">2</span> == <span class="number">0</span> ? n/<span class="number">2</span> : <span class="literal">nil</span>&#125;</div><div class="line"><span class="comment">//[1, 2, 3, 4, 5]</span></div></pre></td></tr></table></figure>
<h3 id="动机-2"><a href="#动机-2" class="headerlink" title="动机"></a>动机</h3><p>可以看到嵌套的序列已经有了懒加载的<code>flatMap</code>，缺少可选序列的懒加载版本像是一个空缺。懒加载序列的有用性已经被记录，特使是当在函数链中快速重构嵌套的for循环时，能在早期不必要分配中期数组</p>
<h3 id="协议的提出"><a href="#协议的提出" class="headerlink" title="协议的提出"></a>协议的提出</h3><p>利用基础库中已经存在类型，<code>flatMap</code>的功能能通过<code>map</code>-<code>filter</code>-<code>map</code>链实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LazySequenceType</span> </span>&#123;</div><div class="line">	<span class="meta">@warn_unused_result</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;T&gt;<span class="params">(transform: Elements.Generator.Element -&gt;T?)</span></span>-&gt; <span class="type">LazyMapSequence</span>&lt;<span class="type">LazyFilterSequece</span>&lt;<span class="type">LazyMapSequence</span>&lt;<span class="type">Elements</span>,<span class="type">T</span>?&gt;&gt;,<span class="type">T</span>&gt;</div><div class="line">	&#123;</div><div class="line">		reutrn <span class="keyword">self</span></div><div class="line">		.<span class="built_in">map</span>(transform)</div><div class="line">		.<span class="built_in">filter</span>&#123;opt <span class="keyword">in</span> opt != <span class="literal">nil</span>&#125;</div><div class="line">		.<span class="built_in">map</span>&#123;notNil <span class="keyword">in</span> notNil!&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="详细设计-1"><a href="#详细设计-1" class="headerlink" title="详细设计"></a>详细设计</h3><p><code>LazyCollectionType</code>的版本几乎相同</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LazyCollectionType</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@warn_unused_result</span> </div><div class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;T&gt;<span class="params">(transform: Elements.Generator.Element -&gt; T?)</span></span> -&gt; <span class="type">LazyMapCollection</span>&lt;<span class="type">LazyFilterCollection</span>&lt;<span class="type">LazyMapCollection</span>&lt;<span class="type">Elements</span>,<span class="type">T</span>?&gt;&gt;,<span class="type">T</span>&gt;</div><div class="line">	&#123;</div><div class="line">	 <span class="keyword">return</span> <span class="keyword">self</span></div><div class="line">	 .mao(transform)</div><div class="line">	 .<span class="built_in">filter</span> &#123;opt <span class="keyword">in</span> opt != <span class="literal">nil</span>&#125;</div><div class="line">	 .<span class="built_in">map</span> &#123;notNil <span class="keyword">in</span> notNil!&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而，一个双向的版本不能用这种方法书写，当没有<code>FilterBidirectionalCollection</code>存在的时候。</p>
<p>在嵌套序列上，<code>flatMap</code>的其他形式使用了<code>flatten</code>方法，它拥有了<code>CollectionType</code>的形式和一个带有<code>BidirectionalIndexType</code>的<code>CollectionType</code>形式</p>
<p>然而，Swift的当前类型系统不允许一个相同函数被定义在可选序列中，这意味着我们必须依靠<code>filter</code>，这个只有<code>SequenceType</code>和<code>CollectionType</code>的实现</p>
<h3 id="可替代考虑"><a href="#可替代考虑" class="headerlink" title="可替代考虑"></a>可替代考虑</h3><h4 id="自定义结构"><a href="#自定义结构" class="headerlink" title="自定义结构"></a>自定义结构</h4><p>在<code>LazySequenceType</code>中添加一个新的结构和一个新的函数是可能的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">FlatMapOptionalGenerator</span>&lt;<span class="title">G</span>: <span class="title">GeneratorType</span>,<span class="title">Element</span>&gt;:<span class="title">GeneratorType</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">let</span> transform: <span class="type">G</span>.<span class="type">Element</span> -&gt; <span class="type">Element</span>?</div><div class="line">	<span class="keyword">private</span> <span class="keyword">var</span> generator: <span class="type">G</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">next</span><span class="params">()</span></span> -&gt; <span class="type">Element</span>?&#123;</div><div class="line">	<span class="keyword">while</span> <span class="keyword">let</span> next = generator.next() &#123;</div><div class="line">		<span class="keyword">if</span> <span class="keyword">let</span> transformed = transform(next) &#123;</div><div class="line">		<span class="keyword">return</span> transformed</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">FlatMapOptionalSequence</span>&lt;<span class="title">S</span>: <span class="title">LazySequenceType</span>,<span class="title">Element</span>&gt;: <span class="title">LazySequenceType</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">let</span> transform: <span class="type">S</span>.<span class="type">Generator</span>.<span class="type">Element</span> -&gt; <span class="type">Element</span>?</div><div class="line">	<span class="keyword">private</span> <span class="keyword">let</span> sequence:<span class="type">S</span></div><div class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">generate</span><span class="params">()</span></span> -&gt; <span class="type">FlatMapOptionalGenerator</span>&lt;<span class="type">S</span>.<span class="type">Generator</span>,<span class="type">Element</span>&gt;&#123;</div><div class="line">	<span class="keyword">return</span> <span class="type">FlatMapOptionlGenerator</span>(transform: transform,generator: sequence.generate())</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">LazySequenceType</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;T&gt;<span class="params">(transform:Generator.Element-&gt;T?)</span></span>-&gt;<span class="type">FlatMapOptionSequence</span>&lt;<span class="type">Self</span>,<span class="type">T</span>&gt;&#123;</div><div class="line">		<span class="keyword">return</span> <span class="type">FlatMapOptionalSequence</span>(ransform:transform,sequence:<span class="keyword">self</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然而，这个实现没有<code>LazyCollectionType</code>版本。为了添加一个和一个双向实现，6个新的类型将必须被添加到基础库中</p>
<h3 id="新的筛选结构"><a href="#新的筛选结构" class="headerlink" title="新的筛选结构"></a>新的筛选结构</h3><p>这个需要添加一个<code>FilterBidirectionalCollection</code> 到基础库中，可证明地是，在当前这是一个空白区。这是允许<code>flatMap</code>映像彼此，通过添加最少的类型</p>
<h2 id="添加新的Int和UInt初始化函数去转化UnsafePointer和UnsafeMutablePointer"><a href="#添加新的Int和UInt初始化函数去转化UnsafePointer和UnsafeMutablePointer" class="headerlink" title="添加新的Int和UInt初始化函数去转化UnsafePointer和UnsafeMutablePointer"></a>添加新的Int和UInt初始化函数去转化UnsafePointer和UnsafeMutablePointer</h2><h3 id="详细设计-2"><a href="#详细设计-2" class="headerlink" title="详细设计"></a>详细设计</h3><p>该初始化的实现通过使用内置的<code>ptrtoint_Word</code>方法</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">UInt</span> </span>&#123;</div><div class="line">	<span class="keyword">init</span>&lt;<span class="type">T</span>&gt;(bitPattern: <span class="type">UnsafePointer</span>&lt;<span class="type">T</span>&gt;)&#123;</div><div class="line">		<span class="keyword">self</span> = <span class="type">UInt</span>(<span class="type">Builtin</span>.ptrtoint_Word(bitPattern._rawValue))</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">init</span>&lt;<span class="type">T</span>&gt;(bitPattern:<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">T</span>&gt;)&#123;</div><div class="line">	<span class="keyword">self</span> = <span class="type">UInt</span>(<span class="type">Builtin</span>.ptrtoint_Word(<span class="type">BitPattern</span>._rawValue))</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">init</span>(bitPattern: <span class="type">OpaquePointer</span>)&#123;</div><div class="line">	<span class="keyword">self</span> = <span class="type">UInt</span>(<span class="type">Builtin</span>.ptrtoint_Word(bitPattern._rawValue))</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>&#123;</div><div class="line">	<span class="keyword">init</span>&lt;<span class="type">T</span>&gt;(<span class="type">BitPattern</span>:<span class="type">UnsafePointer</span>&lt;<span class="type">T</span>&gt;) &#123;</div><div class="line">		<span class="keyword">self</span> = <span class="type">Int</span>(<span class="type">Builtin</span>.ptrtoint_Word(bitPattern._rawValue))</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">init</span>&lt;<span class="type">T</span>&gt;(bitPattern: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">T</span>&gt;) &#123;</div><div class="line">		<span class="keyword">self</span> = <span class="type">Int</span>(<span class="type">Builtin</span>.ptrtoint_Word(bitPattern._rawValue))</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">init</span>(bitPattern: <span class="type">OpaquePointer</span>)&#123;</div><div class="line">		<span class="keyword">self</span> = <span class="type">Int</span>(<span class="type">Builtin</span>.ptrtoint_Word(bitPattern._rawValue))</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>举例，这个初始化能允许使用者获得XOR列表的下一个地址</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">XORLinkedList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">let</span> address: <span class="type">UnsafePointer</span>&lt;<span class="type">T</span>&gt;</div><div class="line">	</div><div class="line">	...</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">func</span> <span class="title">successor</span><span class="params">(<span class="number">_</span> predecessor: XORLinkedList&lt;T&gt;)</span></span> -&gt; <span class="type">XORLinkedList</span>&lt;<span class="type">T</span>&gt; &#123;</div><div class="line">		<span class="keyword">let</span> next = <span class="type">UInt</span>(bitPattern: address) ^ <span class="type">UInt</span>(bitPattern:predecessor.address)</div><div class="line">		<span class="keyword">return</span> <span class="type">XorLinkedList</span>(<span class="type">UnsafePointer</span>&lt;<span class="type">T</span>&gt;(bitPattern: next))</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="更改Unmanaged使用UnsafePointer"><a href="#更改Unmanaged使用UnsafePointer" class="headerlink" title="更改Unmanaged使用UnsafePointer"></a>更改<code>Unmanaged</code>使用<code>UnsafePointer</code></h2><h3 id="介绍-5"><a href="#介绍-5" class="headerlink" title="介绍"></a>介绍</h3><p>基础库中的<code>Unmanaged&lt;Instance&gt;</code> 结构提供了一个类型安全对象包装那些没有加入ARC的;这运行使用者手动使用retain/release调用</p>
<h3 id="动机-3"><a href="#动机-3" class="headerlink" title="动机"></a>动机</h3><p>下列函数提供了转化成Unmanaged和从Unmanaged转化</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">fromOpaque</span><span class="params">(Value:COpaquePointer)</span></span> -&gt; <span class="type">Unmanaged</span>&lt;<span class="type">Instance</span>&gt;</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">toOpaque</span><span class="params">()</span></span> -&gt; <span class="type">COpaquePointer</span></div></pre></td></tr></table></figure>
<p>然而，接受<code>void *</code>和<code>const void*</code>的C APIs暴露在Swift中的是<code>UnsafePointer&lt;Void&gt;</code>和<code>UnsafeMutablePointer&lt;Void&gt;</code>，而不是<code>COpaquePointer</code>。实际上，使用者必须转化 <code>UnsagePointer</code>-&gt;<code>COpaquePointer</code>-&gt;<code>Unmanaged</code>,者导致代码膨胀</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">someFunction(context: <span class="type">UnsafeMutablePointer</span>(unmanaged.passUnretained(<span class="keyword">self</span>).toOpaque()))</div><div class="line">info.retain = &#123; <span class="type">Unmanaged</span>&lt;<span class="type">AnyObject</span>&gt;.fromOpaque(<span class="type">CopaquePointer</span>($<span class="number">0</span>).retain())</div><div class="line">&#125;</div><div class="line">info.copyDescription = &#123; </div><div class="line"><span class="type">Unmanaged</span>.passRetained(<span class="type">CFCopyDescription</span>(<span class="type">Unmanaged</span>.fromOpaque(<span class="type">COpaquePointer</span>($<span class="number">0</span>)).takeUnretainedValue()))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="提出解决"><a href="#提出解决" class="headerlink" title="提出解决"></a>提出解决</h3><p>在<code>Unmanaged</code>API中，用<code>UnsafePointer&lt;Void&gt;</code>和<code>UnsafeMutablePointer&lt;Void&gt;</code>替代<code>COpaquePointer</code>的使用</p>
<p>受影响的函数是<code>fromOpaque()</code>和<code>toOpaque</code>。仅仅要求从当前实现中做出很小的改变。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@_transparent</div><div class="line"><span class="meta">@warn_unused_result</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">fromOpaque</span><span class="params">(value: UnsafePointer&lt;Void&gt;)</span></span> -&gt; <span class="type">Unmanaged</span> &#123;</div><div class="line">    <span class="comment">// Null pointer check is a debug check, because it guards only against one</span></div><div class="line">    <span class="comment">// specific bad pointer value.</span></div><div class="line">    _debugPrecondition(</div><div class="line">      value != <span class="literal">nil</span>,</div><div class="line">      <span class="string">"attempt to create an Unmanaged instance from a null pointer"</span>)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="type">Unmanaged</span>(_private: <span class="built_in">unsafeBitCast</span>(value, <span class="type">Instance</span>.<span class="keyword">self</span>))</div><div class="line">&#125;</div><div class="line"></div><div class="line">@_transparent</div><div class="line"><span class="meta">@warn_unused_result</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">toOpaque</span><span class="params">()</span></span> -&gt; <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt; &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">unsafeBitCast</span>(_value, <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;.<span class="keyword">self</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意到<code>UnsafeMutablePointer</code>类型的值能被函数接受，包括<code>UnsafePointer</code>或<code>UnsafeMutablePointer</code>，所以为了精简和容易使用，我们选择<code>UnsafePointer</code>作为<code>fromOpaque()</code>的输入类型，<code>UnsafeMutablePointer</code>作为<code>toOpaque()</code>的返回类型</p>
<p>上面例子不在需要请求转变</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">someFunction(context: <span class="type">Unmanaged</span>.passUnretained(<span class="keyword">self</span>).toOpaque())</div><div class="line"></div><div class="line">info.retain = &#123; <span class="type">Unmanaged</span>&lt;<span class="type">AnyObject</span>&gt;.fromOpaque($<span class="number">0</span>).retain() &#125;</div><div class="line">info.copyDescription = &#123;</div><div class="line">    <span class="type">Unmanaged</span>.passRetained(<span class="type">CFCopyDescription</span>(<span class="type">Unmanaged</span>.fromOpaque($<span class="number">0</span>).takeUnretainedValue()))</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="现代Swift的调试标识"><a href="#现代Swift的调试标识" class="headerlink" title="现代Swift的调试标识"></a>现代Swift的调试标识</h2><p>主要讲<code>__FILE__</code>，<code>__LINE__</code>，<code>__COLUMN__</code>，<code>__FUNCTION__</code>和<code>__DSO_HANDLE__</code>等调试标识 改为<code>#file</code><br>，<code>#line</code>，<code>#column</code>，<code>#function</code>和<code>#dsohandle</code></p>
<h2 id="从功能函数中删除元组隐藏的图示行为"><a href="#从功能函数中删除元组隐藏的图示行为" class="headerlink" title="从功能函数中删除元组隐藏的图示行为"></a>从功能函数中删除元组隐藏的图示行为</h2><p>删除用元组来传递函数参数的语法糖<br>例如：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">以前：</div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(<span class="number">_</span> :Int,b：Int)</span></span></div><div class="line">&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> x = (<span class="number">10</span>,b:<span class="number">2</span>)</div><div class="line">foo(x) <span class="comment">//将参数通过元组传递</span></div><div class="line"></div><div class="line">现在：</div><div class="line">foo(x.<span class="number">0</span>,x.b)</div></pre></td></tr></table></figure>
<h2 id="整理inout的类型修饰声明"><a href="#整理inout的类型修饰声明" class="headerlink" title="整理inout的类型修饰声明"></a>整理<code>inout</code>的类型修饰声明</h2><ul>
<li><p>允许<code>inout</code>和泛型相结合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(x: inout T)-&gt;U // =&gt; (inout T) -&gt; U</div></pre></td></tr></table></figure>
</li>
<li><p>避免使用和<code>inout</code>类似的符合来作为参数标签，例如</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">func foo(inOut x: T) // foo(inOut:), type (T) -&gt; Void</div><div class="line">func foo(inout x: T) // foo(_:), type (inout T) -&gt; Void</div></pre></td></tr></table></figure>
<ul>
<li><code>inout</code>作为一个关键字，不能成为参数名</li>
<li></li>
</ul>
<h3 id="详细设计-3"><a href="#详细设计-3" class="headerlink" title="详细设计"></a>详细设计</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">parameter → external-parameter-name optlocal-parameter-name : type-annotation</div><div class="line">type-annotation → inout type-annotation</div></pre></td></tr></table></figure>
<h2 id="在-SequenceType-中添加-first-where-函数"><a href="#在-SequenceType-中添加-first-where-函数" class="headerlink" title="在 SequenceType 中添加 first(where:) 函数"></a>在 SequenceType 中添加 first(where:) 函数</h2><h2 id="导入的Objective-C-常量作为-Swift-类型"><a href="#导入的Objective-C-常量作为-Swift-类型" class="headerlink" title="导入的Objective-C 常量作为 Swift 类型"></a>导入的Objective-C 常量作为 Swift 类型</h2><h2 id="消除调试标识中Line控制声明的歧意"><a href="#消除调试标识中Line控制声明的歧意" class="headerlink" title="消除调试标识中Line控制声明的歧意"></a>消除调试标识中Line控制声明的歧意</h2><p>重载<code>#line</code>的使用意味着一个映射文件内调用站点行数的识别码和行为作为了行控制声明的一部分。</p>
<p>这个建议指定<code>#setline</code>去替换<code>#line</code>控制文件和行语法源</p>
<p>将<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">line-control-statement → #line</div><div class="line">line-control-statement → #line line-number file-name</div><div class="line">line-number → A decimal integer greater than zero</div><div class="line">file-name → static-string-literal</div></pre></td></tr></table></figure></p>
<p>改为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">line-control-statement → #setline</div><div class="line">line-control-statement → #setline line-number file-name</div><div class="line">line-number → A decimal integer greater than zero</div><div class="line">file-name → static-string-literal­</div></pre></td></tr></table></figure>
<h2 id="明确注释和运算符的交互作用"><a href="#明确注释和运算符的交互作用" class="headerlink" title="明确注释和运算符的交互作用"></a>明确注释和运算符的交互作用</h2><p>在运算区域内，将注释当做是一个空格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if/* comment */!foo &#123; ... &#125;</div><div class="line">if !foo &#123; ... &#125;</div><div class="line"></div><div class="line">// whitespace on both sides</div><div class="line">1 + 2</div><div class="line">1 +/* comment */2</div></pre></td></tr></table></figure>
<h2 id="用冒号替代属性参数中的等于号"><a href="#用冒号替代属性参数中的等于号" class="headerlink" title="用冒号替代属性参数中的等于号"></a>用冒号替代属性参数中的等于号</h2><h2 id="在具有多个模式的‘case’中声明变量"><a href="#在具有多个模式的‘case’中声明变量" class="headerlink" title="在具有多个模式的‘case’中声明变量"></a>在具有多个模式的‘case’中声明变量</h2><h3 id="介绍-6"><a href="#介绍-6" class="headerlink" title="介绍"></a>介绍</h3><p>在Swift2，在一个case中匹配多模式是可能的。然而，但case什么变量时，cases不能包含多模式</p>
<p>下面代码现场报出错误</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MyEnum</span> </span>&#123;</div><div class="line"> 	<span class="keyword">case</span> <span class="type">Case1</span>(<span class="type">Int</span>,<span class="type">Float</span>)</div><div class="line"> 	<span class="keyword">case</span> <span class="type">Case2</span>(<span class="type">Float</span>,<span class="type">Int</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">swith value &#123;</div><div class="line"><span class="keyword">case</span> <span class="keyword">let</span> .<span class="type">Case1</span>(x,<span class="number">2</span>),<span class="keyword">let</span> .<span class="type">Case2</span>(<span class="number">2</span>,x):</div><div class="line">		<span class="built_in">print</span>(x)</div><div class="line"><span class="keyword">case</span> .<span class="type">Case1</span>,.<span class="type">Case2</span>:</div><div class="line"><span class="keyword">break</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个错误是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">case标签在带有多个模式的情况下，不能声明变量</div></pre></td></tr></table></figure>
<p>这个建议目的在当每一个模式声明相同类型的变量时，删除这个错误</p>
<h3 id="详细设计-4"><a href="#详细设计-4" class="headerlink" title="详细设计"></a>详细设计</h3><p>如果case标签符合下列内容，允许多模式的case标签</p>
<ul>
<li>所有模式声明完全相同的变量</li>
<li>相同的变量拥有相同的类型</li>
</ul>
<p>因此每一个模式都能够为case标签生成相同变量</p>
<p>在<code>if case let</code>的case中的语法的用法也是相同的唯一问题是这个是否能和其他变量结合，和是否不模糊</p>
<p>模式的语法得到下面的改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ enum-case-pattern-list → enum-case-pattern |</div><div class="line">+                          enum-case-pattern , enum-case-pattern-list</div><div class="line">+ pattern  → enum-case-pattern-list</div><div class="line">- pattern  → enum-case-pattern</div></pre></td></tr></table></figure>
<h3 id="其他考虑"><a href="#其他考虑" class="headerlink" title="其他考虑"></a>其他考虑</h3><h4 id="使用闭包和内联函数"><a href="#使用闭包和内联函数" class="headerlink" title="使用闭包和内联函数"></a>使用闭包和内联函数</h4><p>代码重复能被减少到每一个‘case’只有一个模式并且通过使用内联函数来控制结果</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleCase</span><span class="params">(value:MyEnum, apply: Int-&gt;Int)</span></span>-&gt;<span class="type">Int</span> &#123;</div><div class="line">	<span class="function"><span class="keyword">func</span> <span class="title">handleX</span><span class="params">(x:Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">		<span class="keyword">return</span> apply(x) + <span class="number">1</span></div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">let</span> out: <span class="type">Int</span></div><div class="line">	</div><div class="line">	<span class="keyword">switch</span> value &#123;</div><div class="line">	 <span class="keyword">case</span> .<span class="type">Case1</span>(<span class="keyword">let</span> x,<span class="number">2</span>):</div><div class="line">	  	out = handleX(x)</div><div class="line">	 <span class="keyword">case</span> .<span class="type">Case2</span>(<span class="number">2</span>,<span class="keyword">let</span> x):</div><div class="line">	 	out = handleX(x)</div><div class="line">	 <span class="keyword">case</span> .<span class="type">Case1</span>, .<span class="type">Case2</span>:</div><div class="line">	 	out = -<span class="number">1</span></div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> out</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个语法更加啰嗦，使得控制流跟令人困惑，并且有一个限制是内联函数可能别捕获</p>
<h4 id="拓展fallthrough语法"><a href="#拓展fallthrough语法" class="headerlink" title="拓展fallthrough语法"></a>拓展fallthrough语法</h4><p>一个简单能够实现减少代码重复的方法是fallthrough允许变量能被映射到下一个case，例如</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> test &#123;</div><div class="line">    <span class="keyword">case</span> .<span class="type">Case1</span>(<span class="keyword">let</span> x, <span class="number">2</span>): </div><div class="line">        <span class="keyword">fallthrough</span> .<span class="type">Case2</span>(<span class="number">_</span>, x)</div><div class="line">    <span class="keyword">case</span> .<span class="type">Case2</span>(<span class="number">3</span>, .<span class="keyword">let</span> x):</div><div class="line">        <span class="built_in">print</span>(<span class="string">"x: \(x)"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这不是简易的方法，是一个黑客，并且fallthrough应该可能被阻拦。这会更灵活，一个编程人员能够接受一个x的值从前面的fallthrough。灵活增加了编程人员错误的机会。也许没有代码重复那么多。</p>
<h4 id="可链式模式匹配"><a href="#可链式模式匹配" class="headerlink" title="可链式模式匹配"></a>可链式模式匹配</h4><h2 id="输入成员"><a href="#输入成员" class="headerlink" title="输入成员"></a>输入成员</h2><h3 id="介绍-7"><a href="#介绍-7" class="headerlink" title="介绍"></a>介绍</h3><p>Swift引入C声明，允许Swift代码自然的和C的库和框架进行交互。但是，这些交互的APIs在Swfit中感觉不自然。这个题案目的是为CAPI的作者提供一套机制去指定导入的函数和变量在被导入Swift类型中作为成员的能力。追求为那些遵循统一A，有纪律的公约的APIs提供一个自动交互选项</p>
<h3 id="动机-4"><a href="#动机-4" class="headerlink" title="动机"></a>动机</h3><p>C APIs和框架导入Swift中作为全局函数和全局变量。在Swift和这些交互感觉不方便</p>
<p>这里有一个纲领性使用Core Graphics C绘图的例子</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">drawRect</span><span class="params">(rect: CGRect)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> context: <span class="type">CGContext</span> = <span class="type">UIGraphicsGetCurrentContext</span>()!</div><div class="line">    <span class="keyword">let</span> toCenter = <span class="type">CGPoint</span>(x: bounds.width/<span class="number">2.0</span>, y: bounds.height/<span class="number">2.0</span>)</div><div class="line">    <span class="keyword">let</span> angle = <span class="type">CGFloat</span>(<span class="type">M_PI</span> / <span class="number">16</span>)</div><div class="line"></div><div class="line">    <span class="keyword">var</span> transform = <span class="type">CGAffineTransformIdentity</span></div><div class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">32</span> &#123;</div><div class="line">        triangulateRect(bounds, inputTransform: transform, context: context)</div><div class="line">        transform = <span class="type">CGAffineTransformTranslate</span>(transform, toCenter.x, toCenter.y)</div><div class="line">        transform = <span class="type">CGAffineTransformRotate</span>(transform, angle)</div><div class="line">        transform = <span class="type">CGAffineTransformTranslate</span>(transform, -toCenter.x, -toCenter.y)</div><div class="line">    &#125;</div><div class="line">    <span class="type">CGContextSetLineWidth</span>(context, bounds.size.width / <span class="number">100</span>)</div><div class="line">    <span class="type">CGContextSetGrayStrokeColor</span>(context, <span class="number">0.5</span>, <span class="number">1.0</span>)</div><div class="line">    <span class="type">CGContextDrawPath</span>(context, .<span class="type">Stroke</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">triangulateRect</span><span class="params">(bounds: CGRect, inputTransform: CGAffineTransform,</span></span></div><div class="line">        context: CGContext) &#123;</div><div class="line">    <span class="keyword">var</span> transform = inputTransform</div><div class="line"></div><div class="line">    <span class="comment">// Triangle from top left corner, to bottom middle, to top right, and then</span></div><div class="line">    <span class="comment">// draw the boundary</span></div><div class="line">    <span class="keyword">let</span> topLeft = bounds.origin</div><div class="line">    <span class="keyword">let</span> bottomRight = <span class="type">CGPoint</span>(x: bounds.size.width, y: bounds.size.height)</div><div class="line">    <span class="keyword">let</span> path = <span class="type">CGPathCreateMutable</span>()</div><div class="line">    <span class="type">CGPathMoveToPoint</span>(path, &amp;transform, topLeft.x, topLeft.y)</div><div class="line">    <span class="type">CGPathAddLineToPoint</span>(path, &amp;transform, <span class="type">CGRectGetMidX</span>(bounds), bottomRight.y)</div><div class="line">    <span class="type">CGPathAddLineToPoint</span>(path, &amp;transform, bottomRight.x, topLeft.y)</div><div class="line">    <span class="type">CGPathAddLineToPoint</span>(path, &amp;transform, topLeft.x, topLeft.y)</div><div class="line">    <span class="type">CGPathAddLineToPoint</span>(path, &amp;transform, topLeft.x, bottomRight.y)</div><div class="line">    <span class="type">CGPathAddLineToPoint</span>(path, &amp;transform, bottomRight.x, bottomRight.y)</div><div class="line">    <span class="type">CGPathAddLineToPoint</span>(path, &amp;transform, bottomRight.x, topLeft.y)</div><div class="line">    <span class="type">CGContextAddPath</span>(context, path)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Swift中，一个更自然的表达应该像这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">override func drawRect(rect: CGRect) &#123;</div><div class="line">    let context: CGContext = UIGraphicsGetCurrentContext()!</div><div class="line">    let toCenter = CGPoint(x: bounds.width/2.0, y: bounds.height/2.0)</div><div class="line">    let angle = CGFloat(M_PI / 16)</div><div class="line"></div><div class="line">    var transform = CGAffineTransform.identity</div><div class="line">    for _ in 0..&lt;32 &#123;</div><div class="line">        triangulateRect(bounds, inputTransform: transform, context: context)</div><div class="line">        transform = transform.translate(toX: toCenter.x, toY: toCenter.y)</div><div class="line">                             .rotate(angle: angle)</div><div class="line">                             .translate(toX: -toCenter.x, toY: -toCenter.y)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    context.lineWidth = bounds.size.width / 100</div><div class="line">    context.strokeColor = CGColor(gray: 0.5, alpha: 1.0)</div><div class="line">    context.drawPath(mode: .Stroke)</div><div class="line">&#125;</div><div class="line"></div><div class="line">func triangulateRect(bounds: CGRect, inputTransform: CGAffineTransform,</div><div class="line">        context: CGContext) &#123;</div><div class="line">    var transform = inputTransform</div><div class="line"></div><div class="line">    // Triangle from top left corner, to bottom middle, to top right, and then</div><div class="line">    // draw the boundary</div><div class="line">    let topLeft = bounds.origin</div><div class="line">    let bottomRight = CGPoint(x: bounds.size.width, y: bounds.size.height)</div><div class="line">    let path = CGMutablePath()</div><div class="line">    path.move(transform: &amp;transform, x: topLeft.x, y: topLeft.y)</div><div class="line">    path.addLine(transform: &amp;transform, x: bounds.midX, y: bottomRight.y)</div><div class="line">    path.addLine(transform: &amp;transform, x: bottomRight.x, y: topLeft.y)</div><div class="line">    path.addLine(transform: &amp;transform, x: topLeft.x, y: topLeft.y)</div><div class="line">    path.addLine(transform: &amp;transform, x: topLeft.x, y: bottomRight.y)</div><div class="line">    path.addLine(transform: &amp;transform, x: bottomRight.x, y: bottomRight.y)</div><div class="line">    path.addLine(transform: &amp;transform, x: bottomRight.x, y: topLeft.y)</div><div class="line">    context.addPath(path)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>目前，C框架提供自然Swift表达的方法是编辑的大量包装或Swift封装</p>
<h3 id="解决建议"><a href="#解决建议" class="headerlink" title="解决建议"></a>解决建议</h3><h4 id="规范手册"><a href="#规范手册" class="headerlink" title="规范手册"></a>规范手册</h4><p>C框架作者应该有方法去规范化指定他们的APIs如何在Swift中呈现，超出目前提供的 NS_SWIFT_NAME的有限功能。这个包括了为每一个给定的被导入的变量或方法指定一个类型的能力。和这个包括了指定一个导入函数被作为计算属性类型的get或set的能力</p>
<p>这个目标是使得开发者使用这些已经应用规范注释额C框架开发时，像使用面向对象接口一样自然</p>
<h4 id="自动推断"><a href="#自动推断" class="headerlink" title="自动推断"></a>自动推断</h4><p>和规范手册配对的功能是自动推断。这个推断系统分析C全局命名和类型，尝试从这个全局中找到一个可导入的Swift类型去扩展成一个方法，初始化或属性</p>
<p>这个推断系统目标是能够自动控制在CF-类型框架中的大多数全局变量和函数，和在未来能扩展成有利于其他有好的结构和纪律的APIs</p>
<p>修正：自动推断将默认不会对所有的CAPIs使用，但这将是一个可选的。</p>
<h4 id="直接映射到C调用公约"><a href="#直接映射到C调用公约" class="headerlink" title="直接映射到C调用公约"></a>直接映射到C调用公约</h4><p>包装盒覆盖有一个缺点，就是为了到达底层C的API导致额外的函数调用跳跃</p>
<p>这个提案提议导入APIs直接映射到底层CAPIs，而不调用通过中间人包装或覆盖的定义。例如成员，这意味值在适当的参数槽中提供一个参考</p>
<h3 id="详细设计-5"><a href="#详细设计-5" class="headerlink" title="详细设计"></a>详细设计</h3><h4 id="swift-name-属性"><a href="#swift-name-属性" class="headerlink" title="swift_name 属性"></a>swift_name 属性</h4><p>一个和Swift编译器交流API应该怎么被导入的规范机制是<code>swift_name</code>属性。<code>swift_name</code>被扩展成允许使用者去为被导入的函数提供一个成员类型，和允许指定一个函数作为计算类型的getter和setter</p>
<p>例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Inport as init </span></div><div class="line"><span class="comment">// 导入作为初始函数</span></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point3D</span> <span class="title">createPoint3D</span>(<span class="title">float</span> <span class="title">x</span>,<span class="title">float</span> <span class="title">y</span>,<span class="title">float</span> <span class="title">z</span>)</span></div><div class="line">__attribute((<span class="title">swift_name</span>("<span class="title">Point3D</span>.<span class="title">init</span>(<span class="title">s</span>:<span class="title">y</span>:<span class="title">z</span>)")));</div><div class="line"></div><div class="line"></div><div class="line">// 导入作为方法</div><div class="line"><span class="title">struct</span> <span class="title">Point3D</span> <span class="title">rotatePoint3D</span>(<span class="title">Point3D</span> <span class="title">point</span>,<span class="title">float</span> <span class="title">raidans</span>)</div><div class="line">__attribute((<span class="title">swift_name</span>(<span class="title">Point3D</span>.<span class="title">rotate</span>(<span class="title">self</span>:<span class="title">radians</span>:)")));</div><div class="line"></div><div class="line">// 导入作为一个计算属性的实例</div><div class="line"></div><div class="line"><span class="title">float</span> <span class="title">Point3DGetRadius</span>(<span class="title">Point3D</span> <span class="title">point</span>)</div><div class="line">__attribute__((<span class="title">swift_name</span>("<span class="title">getter</span>:<span class="title">Point3D</span>.<span class="title">radius</span>(<span class="title">self</span>;)")));</div><div class="line"><span class="title">void</span> <span class="title">Point3DSetRadius</span>(<span class="title">Point3D</span> <span class="title">point</span>, <span class="title">float</span> <span class="title">raidus</span>)</div><div class="line">__attribute__((<span class="title">swift_name</span>("<span class="title">setter</span>:<span class="title">Point3D</span>.<span class="title">radius</span>(<span class="title">self</span>:_:)")));</div><div class="line"></div><div class="line">//导入作为一个静态属性</div><div class="line"></div><div class="line"><span class="title">extern</span> <span class="title">struct</span> <span class="title">Point3D</span> <span class="title">identityPoint</span></div><div class="line">__attribute__((<span class="title">swift_name</span>("<span class="title">Point3D</span>.<span class="title">identity</span>")));</div><div class="line"></div><div class="line">//导入作为静态计算属性</div><div class="line"><span class="title">Point3D</span> <span class="title">getZeroPoint</span>(<span class="title">void</span>)</div><div class="line">__attribute((<span class="title">swift_name</span>("<span class="title">getter</span>:<span class="title">Point3D</span>.<span class="title">zero</span>()")));</div><div class="line"></div><div class="line"><span class="title">void</span> <span class="title">setZeroPoint</span>(<span class="title">Point3D</span> <span class="title">point</span>)</div><div class="line">__attribute__((<span class="title">swift_name</span>("<span class="title">setter</span>:<span class="title">Point3D</span>.<span class="title">zero</span>(_:)")));</div></pre></td></tr></table></figure>
<p>改进：一直运行导入作为下标</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//导入作为下标</span></div><div class="line"></div><div class="line">float <span class="type">Point3DGetPointAtIndex</span>(int idx,<span class="type">Point3D</span> point)</div><div class="line">__attribute__((swift_name(<span class="string">"getter:subscript(_:self:)"</span>)))</div><div class="line">void <span class="type">Point3DSetPointAtIndex</span>(int idx,<span class="type">Point3D</span> point,float val)</div><div class="line">__attribute__((swift_name(<span class="string">"getter:subscript(_:self:newValue:)"</span>)))</div></pre></td></tr></table></figure>
<p>在swift_name中字符串的额外支持如下：</p>
<ul>
<li>一个类型紧接着<code>.</code>来表示导入内容</li>
<li><code>self</code>表示这个参数处理其本身的实例，否则这个表示静态方法/属性</li>
<li><code>getter:</code>和<code>setter:</code>来表示函数作为属性的getter/setter</li>
</ul>
<p>改进：swift_name 在非原型函数声明中是无效的</p>
<p>改进：swift_name能被使用去添加成员实例在命名协议的拓展，但这个限制了成员实例。导入成为静态函数或初始化是不被支持的。被导入成员实例在协议拓展，强制静态派遣</p>
<h4 id="自动启发式推断"><a href="#自动启发式推断" class="headerlink" title="自动启发式推断"></a>自动启发式推断</h4><p>下面的一些技术和启发能被使用去统一CAPIs的命名。例如：CF-style框架。这个启发基于变量/函数的名和类型</p>
<ul>
<li>通过返回类型标识inti</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- <span class="function"><span class="keyword">func</span> <span class="title">CGColorCreate</span><span class="params">(space: CGColorSpace?, <span class="number">_</span> components: UnsagePointer&lt;CGFloat&gt;)</span></span> -&gt; <span class="type">CGColor</span>?</div><div class="line"></div><div class="line"><span class="comment">// extension CGColor &#123; ...</span></div><div class="line"></div><div class="line">+ <span class="keyword">init</span>?(space: <span class="type">CGColorSpace</span>?,components: <span class="type">UnsafePointer</span>&lt;<span class="type">CGFloat</span>&gt;)</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>通过发现”get“/”set“部分来标识计算属性</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- <span class="function"><span class="keyword">func</span> <span class="title">CGContextGetInterpolationQuality</span><span class="params">(<span class="built_in">c</span>: CGContext?)</span></span> -&gt; <span class="type">CGInterpolationQuality</span></div><div class="line">- <span class="function"><span class="keyword">func</span> <span class="title">CGContextSetInterpolationQuality</span><span class="params">(<span class="built_in">c</span>；CGContext?,<span class="number">_</span> quality: CGInterpolationQUality)</span></span></div><div class="line"></div><div class="line"><span class="comment">// extension CGContext &#123;</span></div><div class="line"> + <span class="keyword">final</span> <span class="keyword">var</span> interpolationQuality: <span class="type">CGInterpolationQuality</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>标识boolean谓语和其他计算属性模型</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- <span class="function"><span class="keyword">func</span> <span class="title">CGDisplayModeIsUsableForDesktopGUI</span><span class="params">(mode: CGDisplayMode?)</span></span> -&gt; <span class="type">Bool</span></div><div class="line"></div><div class="line"><span class="comment">// extension CGDisplayMode &#123;</span></div><div class="line">+ <span class="keyword">final</span> <span class="keyword">var</span> isUsableForDesktopGUI: <span class="type">Bool</span>&#123; <span class="keyword">get</span> &#125;</div></pre></td></tr></table></figure>
<ul>
<li>通过找到self参数标识函数</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- <span class="function"><span class="keyword">func</span> <span class="title">CGAffineTransformInvert</span><span class="params">(t: CGAffineTransform)</span></span> -&gt; <span class="type">CGAffineTransform</span></div><div class="line"></div><div class="line"><span class="comment">// extension CGAffineTransformation &#123;...</span></div><div class="line">+ <span class="function"><span class="keyword">func</span> <span class="title">invert</span><span class="params">()</span></span> -&gt; <span class="type">CGAffineTransform</span></div></pre></td></tr></table></figure>
<ul>
<li>各种各样的特别案例，模糊名字匹配等等</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-<span class="function"><span class="keyword">func</span> <span class="title">CGDisplayStreamUpdateGetTypeId</span><span class="params">()</span></span> -&gt; <span class="type">CFTypeId</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CGDispalyStreamUndate</span> </span>&#123; ..</div><div class="line">+ <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">var</span> <span class="title">typeID</span>: <span class="title">CFTypeId</span> </span>&#123; <span class="keyword">get</span> &#125;</div><div class="line">...</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">CGBitmapContextGetData</span><span class="params">(context:CGContext?)</span></span>-&gt;<span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt;</div><div class="line"></div><div class="line"><span class="comment">// extension CGContext &#123; ...</span></div><div class="line"> + <span class="keyword">final</span> <span class="keyword">var</span> bitmapData: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Void</span>&gt; &#123;<span class="keyword">get</span>&#125;</div></pre></td></tr></table></figure>
<h4 id="底层设施"><a href="#底层设施" class="headerlink" title="底层设施"></a>底层设施</h4><p>Clang导入者被拓展为支持先在不同有效的画板上定义函数和变量，然后在现在是Clang上。另外，Clang导入者将创建一个单一的拓展区指出每一个在模型/类型添加成员的部分。</p>
<p>SILGen将需要拓展CAPI调用和成员调用之间的直接映射，通过适当的self参数定位成员实例。</p>
<h4 id="迁移"><a href="#迁移" class="headerlink" title="迁移"></a>迁移</h4><p>使用老风格的APIs将需要迁移到新的API。当提案的导入以编程的方式在导入程序中运行时，迁移属性能附加在新的描述中，运行Swift迁移者能自动的迁移使用代码</p>
<h2 id="在包括首个标签的所有参数中，建立的统一标签行为"><a href="#在包括首个标签的所有参数中，建立的统一标签行为" class="headerlink" title="在包括首个标签的所有参数中，建立的统一标签行为"></a>在包括首个标签的所有参数中，建立的统一标签行为</h2><p>以前 </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(a: T,b: U, <span class="built_in">c</span>: V)</span></span></div></pre></td></tr></table></figure>
<p>被声明为 <code>foo(_:b:c:)</code>而不是<code>foo(a:b:c)</code></p>
<p>现在</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(x: Int, y:Int)</span></span></div></pre></td></tr></table></figure>
<p>被声明为<code>foo(x:y:)</code>而不是<code>foo(_:,y:)</code></p>
<p>当然，首个参数依旧能提供外部标签</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(xx x:Int ,yy y: Int)</span></span></div></pre></td></tr></table></figure>
<p>被定义为 <code>foo(xx:yy:)</code> 和</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(<span class="number">_</span> x: Int, y: Int)</span></span></div></pre></td></tr></table></figure>
<p>明确被定义为 <code>foo(_:y:)</code></p>
<h3 id="对存在代码的影响-1"><a href="#对存在代码的影响-1" class="headerlink" title="对存在代码的影响"></a>对存在代码的影响</h3><ul>
<li>那些没有包含明确的首个外部标签的函数声明将会明确删除第一个参数的标签（例如：<code>func foo(x: Int, y: Int)</code>将转化为<code>func foo(_ x:Int, y:Int)</code>）</li>
<li>功能调用部分(例子<code>foo(2, y: 3)</code>)将保持不受影响</li>
<li>函数提交(例子<code>#selector(ViewController.foo(_:y:))</code>)将保持不受影响</li>
</ul>
<h2 id="默认情况下，没有使用非空返回函数的返回值，会受到警告"><a href="#默认情况下，没有使用非空返回函数的返回值，会受到警告" class="headerlink" title="默认情况下，没有使用非空返回函数的返回值，会受到警告"></a>默认情况下，没有使用非空返回函数的返回值，会受到警告</h2><h3 id="介绍-8"><a href="#介绍-8" class="headerlink" title="介绍"></a>介绍</h3><p>在Swift的当前体现中，为方法和函数添加<code>@warn_unused_result</code>注释将会通知编译器说，这个非空的返回类型将会被使用。这是一个肯定的声明。在它不在是，忽略函数的返回结果将不会有警告或错误</p>
<p>在当前的规范中，这个声明属性在可变和不可变部分有主要地不同。当一个期望返回类型被使用时，提供一个可选<code>mutable_variant</code>。例如，当<code>sort</code>被调用但不使用返回结果是，编译器将建议使用<code>sortInPlace</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@warn_unused_result(mutable_variant=&quot;sortInPlace&quot;) </div><div class="line">public func sort() -&gt; [Self.Generator.Element]</div></pre></td></tr></table></figure>
<p>这个提案抛弃了这个默认行为。没有使用返回结果更可能是程序员没有区分可变类型和不可变类型函数部分而产生的错误。这个提案让“警告没有使用结果”成为Swift的方法和函数的默认行为。开发者必须重载这个默认行为，去允许编译器忽略不使用的值</p>
<h3 id="可接受笔记"><a href="#可接受笔记" class="headerlink" title="可接受笔记"></a>可接受笔记</h3><p><code>@discardableResult</code>属性允许API作者去指明编译器不会产生警告，当他们的函数和方法生产一个非必要的结果时。 </p>
<h3 id="详细设计-6"><a href="#详细设计-6" class="headerlink" title="详细设计"></a>详细设计</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@discardableResult <span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> -&gt; <span class="type">T</span>&#123;&#125; <span class="comment">//可能按照程序调用 f() 而不会产生编译警告</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> -&gt; <span class="type">T</span>&#123;&#125; <span class="comment">//默认警告没有使用返回结果</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">h</span><span class="params">()</span></span> &#123;&#125; <span class="comment">// Void 返回类型，不在这个提案的范围内</span></div></pre></td></tr></table></figure>
<p>下面例子示范了<code>@discardableResul</code>的使用行为</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> c1:() -&gt; <span class="type">T</span> = f <span class="comment">// 没有编译警告</span></div><div class="line"><span class="keyword">let</span> c2:() -&gt; <span class="type">Void</span> = f <span class="comment">//编译警告 ，无效的转换</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> c3 = f <span class="comment">// 赋值没有维持 @discardableResult 属性</span></div><div class="line"></div><div class="line">c3() <span class="comment">// 编译警告，没有使用结果</span></div><div class="line"></div><div class="line"><span class="number">_</span> = c3() <span class="comment">// 没有编译警告</span></div></pre></td></tr></table></figure>
<h2 id="普遍类型化名"><a href="#普遍类型化名" class="headerlink" title="普遍类型化名"></a>普遍类型化名</h2><h3 id="介绍-9"><a href="#介绍-9" class="headerlink" title="介绍"></a>介绍</h3><p>这个提议的目的是添加Swift普遍类型化名</p>
<h3 id="动机-5"><a href="#动机-5" class="headerlink" title="动机"></a>动机</h3><p>普遍类型化名是一个存在Swift类型模型的化名的明显推断，这个允许你为存在的正常的普遍类型提供一个别名，或为不正常类型（例子：元组，函数等）包括普遍参数提供一个别名</p>
<h3 id="建议的解决方案"><a href="#建议的解决方案" class="headerlink" title="建议的解决方案"></a>建议的解决方案</h3><p>这个解决方法：允许类型别名引入在定义范围内的类型参数，这个允许表示事情如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typealias</span> <span class="type">StringDictionary</span>&lt;<span class="type">T</span>&gt; = <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">T</span>&gt;</div><div class="line"><span class="keyword">typealias</span> <span class="type">DictionaryOfStrings</span>&lt;<span class="type">T</span> : <span class="type">Hashable</span>&gt; = <span class="type">Dictionary</span>&lt;<span class="type">T</span>, <span class="type">String</span>&gt;</div><div class="line"><span class="keyword">typealias</span> <span class="type">IntFunction</span>&lt;<span class="type">T</span>&gt; = (<span class="type">T</span>) -&gt; <span class="type">Int</span></div><div class="line"><span class="keyword">typealias</span> <span class="type">Vec3</span>&lt;<span class="type">T</span>&gt; = (<span class="type">T</span>, <span class="type">T</span>, <span class="type">T</span>)</div><div class="line"><span class="keyword">typealias</span> <span class="type">BackwardTriple</span>&lt;<span class="type">T1</span>,<span class="type">T2</span>,<span class="type">T3</span>&gt; = （<span class="type">T3</span>,<span class="type">T2</span>,<span class="type">T1</span>）</div></pre></td></tr></table></figure>
<h2 id="移动-noescape-和-autoclosure-成类型属性"><a href="#移动-noescape-和-autoclosure-成类型属性" class="headerlink" title="移动 @noescape 和 @autoclosure 成类型属性"></a>移动 @noescape 和 @autoclosure 成类型属性</h2><h3 id="介绍-10"><a href="#介绍-10" class="headerlink" title="介绍"></a>介绍</h3><p>这个提案建议移动存在的<code>@noescape</code>和<code>@autoclosure</code>属性从参数的声明属性到类型属性。这个增加语言的统一性减少语言的冗余。</p>
<h3 id="建议解决"><a href="#建议解决" class="headerlink" title="建议解决"></a>建议解决</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(@noescape fn : <span class="params">()</span></span></span> -&gt; ()) &#123;&#125;  <span class="comment">// declaration attribute</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(fn : @noescape <span class="params">()</span></span></span> -&gt; ()) &#123;&#125;  <span class="comment">// type attribute.</span></div></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(fn : @noescape <span class="params">()</span></span></span> -&gt; ()) &#123;&#125;     <span class="comment">// type attribute.</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(a : @autoclosure <span class="params">()</span></span></span> -&gt; ()) &#123;&#125;  <span class="comment">// type attribute.</span></div></pre></td></tr></table></figure>
<h2 id="删除函数参数中let的使用"><a href="#删除函数参数中let的使用" class="headerlink" title="删除函数参数中let的使用"></a>删除函数参数中<code>let</code>的使用</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(<span class="keyword">let</span> x: Int)</span></span> &#123; ... &#125;</div><div class="line"></div><div class="line">改为</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(x: Int)</span></span> &#123; ... &#125;</div></pre></td></tr></table></figure>
<h2 id="废除ImplicitlyUnwrappedOptional（隐式解包可选类型）类型"><a href="#废除ImplicitlyUnwrappedOptional（隐式解包可选类型）类型" class="headerlink" title="废除ImplicitlyUnwrappedOptional（隐式解包可选类型）类型"></a>废除<code>ImplicitlyUnwrappedOptional（隐式解包可选类型）</code>类型</h2><h3 id="介绍-11"><a href="#介绍-11" class="headerlink" title="介绍"></a>介绍</h3><p>这个建议目的是删除Swift类型系统中的<code>ImplicitlyUnwrappedOptional</code>类型，并用IUO声明属性代替。在Swift声明类型中追加<code>!</code>将给它可选类型和注明属性状态的声明，声明这个被使用时是隐式解包。</p>
<h3 id="动机-6"><a href="#动机-6" class="headerlink" title="动机"></a>动机</h3><p><code>ImplicitlyUnwrappedOptional</code>(“IUO”)类型是有意义的工具，对于导入的Objective-C APIs，这些可空的参数或返回值没有被指定的。在解决在初始化器中的初始化问题中，这是相当方便机制。然而，IUO是一个转化技术；他们表达了一个容易的方法去绕过未标注的APIs，或语言特征的缺乏，和介绍更多特殊的语言特征去取代他们的位置。除了一些特殊情况，可选一直是一个更安全的赌注，我们更鼓励人民去使用它们而不是IUOs</p>
<p>这个提案目的是限制IUOs使用在确实需要它的地方，和让Swift语言能达到从系统中完整地删除隐式解包可选的目的，当其他技术使它们不被需要时。已经完整地废除了编译器类型检测层中所有的IUOs概念，这将会简化编译器的实现。</p>
<h3 id="建议的解决方法"><a href="#建议的解决方法" class="headerlink" title="建议的解决方法"></a>建议的解决方法</h3><p>在提案中，我们继续使用<code>T!</code>语法去声明隐式解包值在下面位置上：</p>
<ul>
<li>属性和变量的声明</li>
<li>初始化声明</li>
<li>函数和方法声明</li>
<li>下标声明</li>
<li>参数声明</li>
</ul>
<p>然而，在属性和变量类型后的<code>!</code>不再表明这个声明是IUO类似，而是表明这个声明是可选类型，并且这个声明有一个被隐式指定的属性（没有人内够写出或观察到这个属性，当我们可以把它相当于<code>@_autounwrapped</code>）。从此以后，这样的声明被认为是一个IUO声明。</p>
<p>同样地，在函数返回类型后面的<code>!</code>表明了这个函数有可选的返回类型和它的返回类型可能被隐式解包。在初始化声明中<code>init!</code>的使用表明初始化使可失败的，并且初始化返回的类型是隐式可解包类型。在所有的这些案例中，<code>@_autounwrapped</code>属性是被添加在这些声明中的。</p>
<p>一个IUO变量或属性的引用更喜欢和可选类型进行绑定，当也可能在类型检查时被隐式强制解包（例如：转换为基本类型）；这是自我复制IUO类型声明的当前行为。同样地，调用函数应用或初始化的结果，是IUO函数声明的一个引用，更喜欢去retain它的可选类型，但如果需要也可能被隐式强制解包</p>
<p>如果一个表达式能被明确地检查成强可选类型，这将会实现。然而，如果需要的话，类型检查者会后退去重视可选的。这个行为的影响是，任何一个关联被声明为<code>T!</code>的值得表达式的结果将拥有<code>T</code>和<code>T？</code>类型。例如，在下面的代码中：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">let</span> x: <span class="type">Int</span>! = <span class="number">5</span></div><div class="line"><span class="keyword">let</span> y = x</div><div class="line"><span class="keyword">let</span> z = x + <span class="number">0</span></div></pre></td></tr></table></figure>
<p>…<code>x</code>被声明为IUO类型，但是<code>y</code>初始化类型检查为可选类型，<code>y</code>被认为是<code>Int？</code>类型。然而，<code>z</code>的初始化不能检测到<code>x</code>被声明为一个可选类型，所以编译器强制解包并且初始化的类型检测为<code>Int</code></p>
<p>这个模型更加可以预测，因为可以防止隐式传播IUOs代码<br>，和默认将他们转化为强可选类型，更安全可选类型。</p>
<p>一个IUO变量可能被转化成没有可选类型的值，通过在要求非可选类型的环境中评估和使用<code>as</code>运算符明确地转化为非可选类型，将它和一个明确的可选类型绑定或使用强制符号(<code>!</code>)</p>
<p>因为IUOs是一个属性声明而不是类型声明，<code>ImplicitlyUnwrappedOptional</code>类型和长期形成的<code>ImplicitlyUnwrappedOptional&lt;T&gt;</code>语法已经被删除了。嵌套IUOs类型已经不再被允许。这个包括类型有<code>[Int!]</code>和（<code>[Int!,Int!]</code>）</p>
<p>类型别名可能没有和IUO关联的消息，因此，声明<code>typealias X = Int!</code>是非法的。这个包含了被导入的<code>typedef</code>声明。例如：Objective-C中的类型声明：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^ViewHandler)(<span class="built_in">NSView</span> *)</div></pre></td></tr></table></figure>
<p>…是被导入作为Swift的类型声明</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">typealias</span> <span class="type">ViewHandler</span> = (<span class="type">NSView</span>?) -&gt; ()</div></pre></td></tr></table></figure>
<p>注意参数的类型是<code>NSView?</code>,而不是<code>NSView!</code></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> -&gt; <span class="type">Int</span>! &#123; <span class="keyword">return</span> <span class="number">3</span> &#125; <span class="comment">// f: () -&gt; Int?, 是 IUO属性</span></div><div class="line"><span class="keyword">let</span> x1 = f() <span class="comment">// 成功; x1: Int? = 3</span></div><div class="line"><span class="keyword">let</span> x2: <span class="type">Int</span>? = f() <span class="comment">// succeeds; x2: Int? = .some(3)</span></div><div class="line"><span class="keyword">let</span> x3: <span class="type">Int</span>! = f() <span class="comment">// succeeds; x3: Int? = .some(3), 是 IUO属性</span></div><div class="line"><span class="keyword">let</span> x4: <span class="type">Int</span> = f() <span class="comment">// succeeds; x4: Int = 3</span></div><div class="line"><span class="keyword">let</span> a1 = [f()] <span class="comment">// succeeds; a: [Int?] = [.some(3)]</span></div><div class="line"><span class="keyword">let</span> a2: [<span class="type">Int</span>!] = [f()] <span class="comment">// 非法，不可以嵌套IUO类型</span></div><div class="line"><span class="keyword">let</span> a3: [<span class="type">Int</span>] = [f()] <span class="comment">// succeeds; a: [Int] = [3]</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">g</span><span class="params">()</span></span> -&gt; <span class="type">Int</span>! &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125; <span class="comment">// f: () -&gt; Int?, has IUO attribute</span></div><div class="line"><span class="keyword">let</span> y1 = g() <span class="comment">// succeeds; y1: Int? = .none</span></div><div class="line"><span class="keyword">let</span> y2: <span class="type">Int</span>? = g() <span class="comment">// succeeds; y2: Int? = .none</span></div><div class="line"><span class="keyword">let</span> y3: <span class="type">Int</span>! = g() <span class="comment">// succeeds; y3: Int? = .none, has IUO attribute</span></div><div class="line"><span class="keyword">let</span> y4: <span class="type">Int</span> = g() <span class="comment">// 陷阱</span></div><div class="line"><span class="keyword">let</span> b1 = [g()] <span class="comment">// succeeds; b: [Int?] = [.none]</span></div><div class="line"><span class="keyword">let</span> b2: [<span class="type">Int</span>!] = [g()] <span class="comment">// 非法，不可以嵌套IUO类型</span></div><div class="line"><span class="keyword">let</span> b3: [<span class="type">Int</span>] = [g()] <span class="comment">//陷阱</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">p</span>&lt;T&gt;<span class="params">(x: T)</span></span> &#123; <span class="built_in">print</span>(x) &#125;</div><div class="line">p(f()) <span class="comment">// prints "Optional(3)"; p 是 T = Int? 的一个实例</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> x5 = f() &#123;</div><div class="line">  <span class="comment">// 运行, with x5: Int = 3</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> y5 = g() &#123;</div><div class="line">  <span class="comment">// 不运行</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对现有代码的影响"><a href="#对现有代码的影响" class="headerlink" title="对现有代码的影响"></a>对现有代码的影响</h3><ul>
<li>变量绑定那些之前被推断为<code>T!</code>类型的右边值，现在变成<code>T?</code>类型。编译器将会发出错误在那些强烈使用非可选类型的环境，并且将建议使用<code>!</code>运算符进行强制解包值。</li>
<li>明确地使用嵌套IUO类型(<code>[Int!]</code>)将必须被重写成相应的可选类型(<code>[Int?]</code>)，或非可选类型(<code>[Int]</code>)，这取决于在环境中是否适合。然而，大多数使用非嵌套的IUO类型声明将继续正常使用。</li>
<li><code>ImplicitlyUnwrappedOptional</code>类型语法糖的使用将被<code>!</code>代替</li>
</ul>
<p>声明IUO属性是可能的，如下面延迟初始胡部分将依旧可以使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> </span>&#123;</div><div class="line">  <span class="keyword">var</span> x: <span class="type">Int</span>!</div><div class="line">  <span class="keyword">init</span>() &#123;&#125;</div><div class="line">  <span class="function"><span class="keyword">func</span> <span class="title">initLater</span><span class="params">(x someX: Int)</span></span> &#123; x = someX &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="不安全可能为空的指针明确使用可选的"><a href="#不安全可能为空的指针明确使用可选的" class="headerlink" title="不安全可能为空的指针明确使用可选的"></a>不安全可能为空的指针明确使用可选的</h2><h3 id="介绍-12"><a href="#介绍-12" class="headerlink" title="介绍"></a>介绍</h3><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://swift.org/blog/swift-3-0-preview-1-released/" target="_blank" rel="external">Swift 3.0 Preview 1 Released!</a></p>

      
    </div>

    <div>
      
        
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag">#iOS</a>
          
            <a href="/tags/Swift/" rel="tag">#Swift</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/04/25/SDWebImage中的缓存机制/" rel="next" title="SDWebImage中的缓存机制">
                <i class="fa fa-chevron-left"></i> SDWebImage中的缓存机制
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/09/25/ffmpeg音频转码/" rel="prev" title="ffmpeg音频转码">
                ffmpeg音频转码 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  <p>热评文章</p>
  <div class="ds-top-threads" data-range="weekly" data-num-items="4"></div>


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/07/15/Swift3-0变化/"
           data-title="Swift3.0变化" data-url="http://yoursite.com/2016/07/15/Swift3-0变化/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="WillToSky" />
          <p class="site-author-name" itemprop="name">WillToSky</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">19</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/zhshijie" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
          
        </div>

        
        

        
        <div class="links-of-blogroll motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Swift-3-0-变化"><span class="nav-number">1.</span> <span class="nav-text">Swift 3.0 变化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#删除currying-柯里化-func-定义语句"><span class="nav-number">1.1.</span> <span class="nav-text">删除currying(柯里化)func 定义语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍"><span class="nav-number">1.1.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动机"><span class="nav-number">1.1.2.</span> <span class="nav-text">动机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#详细设计"><span class="nav-number">1.1.3.</span> <span class="nav-text">详细设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存在代码的影响"><span class="nav-number">1.1.4.</span> <span class="nav-text">存在代码的影响</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可选择的考虑"><span class="nav-number">1.1.5.</span> <span class="nav-text">可选择的考虑</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除函数参数中的var"><span class="nav-number">1.2.</span> <span class="nav-text">删除函数参数中的var</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#注意"><span class="nav-number">1.2.1.</span> <span class="nav-text">注意</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动机-1"><span class="nav-number">1.2.3.</span> <span class="nav-text">动机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设计"><span class="nav-number">1.2.4.</span> <span class="nav-text">设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对现在代码的影响"><span class="nav-number">1.2.5.</span> <span class="nav-text">对现在代码的影响</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除-和-运算符"><span class="nav-number">1.3.</span> <span class="nav-text">删除 ++和--运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍-2"><span class="nav-number">1.3.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#这些运算符的有利条件"><span class="nav-number">1.3.2.</span> <span class="nav-text">这些运算符的有利条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#这些运算符的不利条件"><span class="nav-number">1.3.3.</span> <span class="nav-text">这些运算符的不利条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除条件和自增的C风格的for循环"><span class="nav-number">1.4.</span> <span class="nav-text">删除条件和自增的C风格的for循环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍-3"><span class="nav-number">1.4.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for循环的优点"><span class="nav-number">1.4.2.</span> <span class="nav-text">for循环的优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#for循环的缺点"><span class="nav-number">1.4.3.</span> <span class="nav-text">for循环的缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拟议方法"><span class="nav-number">1.4.4.</span> <span class="nav-text">拟议方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可选择的考虑-1"><span class="nav-number">1.4.5.</span> <span class="nav-text">可选择的考虑</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对存在代码的影响"><span class="nav-number">1.4.6.</span> <span class="nav-text">对存在代码的影响</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为可选序列添加懒加载的flatMap"><span class="nav-number">1.5.</span> <span class="nav-text">为可选序列添加懒加载的flatMap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍-4"><span class="nav-number">1.5.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动机-2"><span class="nav-number">1.5.2.</span> <span class="nav-text">动机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#协议的提出"><span class="nav-number">1.5.3.</span> <span class="nav-text">协议的提出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#详细设计-1"><span class="nav-number">1.5.4.</span> <span class="nav-text">详细设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可替代考虑"><span class="nav-number">1.5.5.</span> <span class="nav-text">可替代考虑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义结构"><span class="nav-number">1.5.5.1.</span> <span class="nav-text">自定义结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#新的筛选结构"><span class="nav-number">1.5.6.</span> <span class="nav-text">新的筛选结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加新的Int和UInt初始化函数去转化UnsafePointer和UnsafeMutablePointer"><span class="nav-number">1.6.</span> <span class="nav-text">添加新的Int和UInt初始化函数去转化UnsafePointer和UnsafeMutablePointer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#详细设计-2"><span class="nav-number">1.6.1.</span> <span class="nav-text">详细设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#更改Unmanaged使用UnsafePointer"><span class="nav-number">1.7.</span> <span class="nav-text">更改Unmanaged使用UnsafePointer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍-5"><span class="nav-number">1.7.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动机-3"><span class="nav-number">1.7.2.</span> <span class="nav-text">动机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#提出解决"><span class="nav-number">1.7.3.</span> <span class="nav-text">提出解决</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#现代Swift的调试标识"><span class="nav-number">1.8.</span> <span class="nav-text">现代Swift的调试标识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从功能函数中删除元组隐藏的图示行为"><span class="nav-number">1.9.</span> <span class="nav-text">从功能函数中删除元组隐藏的图示行为</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#整理inout的类型修饰声明"><span class="nav-number">1.10.</span> <span class="nav-text">整理inout的类型修饰声明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#详细设计-3"><span class="nav-number">1.10.1.</span> <span class="nav-text">详细设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在-SequenceType-中添加-first-where-函数"><span class="nav-number">1.11.</span> <span class="nav-text">在 SequenceType 中添加 first(where:) 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#导入的Objective-C-常量作为-Swift-类型"><span class="nav-number">1.12.</span> <span class="nav-text">导入的Objective-C 常量作为 Swift 类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消除调试标识中Line控制声明的歧意"><span class="nav-number">1.13.</span> <span class="nav-text">消除调试标识中Line控制声明的歧意</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#明确注释和运算符的交互作用"><span class="nav-number">1.14.</span> <span class="nav-text">明确注释和运算符的交互作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用冒号替代属性参数中的等于号"><span class="nav-number">1.15.</span> <span class="nav-text">用冒号替代属性参数中的等于号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在具有多个模式的‘case’中声明变量"><span class="nav-number">1.16.</span> <span class="nav-text">在具有多个模式的‘case’中声明变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍-6"><span class="nav-number">1.16.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#详细设计-4"><span class="nav-number">1.16.2.</span> <span class="nav-text">详细设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他考虑"><span class="nav-number">1.16.3.</span> <span class="nav-text">其他考虑</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用闭包和内联函数"><span class="nav-number">1.16.3.1.</span> <span class="nav-text">使用闭包和内联函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拓展fallthrough语法"><span class="nav-number">1.16.3.2.</span> <span class="nav-text">拓展fallthrough语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可链式模式匹配"><span class="nav-number">1.16.3.3.</span> <span class="nav-text">可链式模式匹配</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入成员"><span class="nav-number">1.17.</span> <span class="nav-text">输入成员</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍-7"><span class="nav-number">1.17.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动机-4"><span class="nav-number">1.17.2.</span> <span class="nav-text">动机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#解决建议"><span class="nav-number">1.17.3.</span> <span class="nav-text">解决建议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#规范手册"><span class="nav-number">1.17.3.1.</span> <span class="nav-text">规范手册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自动推断"><span class="nav-number">1.17.3.2.</span> <span class="nav-text">自动推断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#直接映射到C调用公约"><span class="nav-number">1.17.3.3.</span> <span class="nav-text">直接映射到C调用公约</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#详细设计-5"><span class="nav-number">1.17.4.</span> <span class="nav-text">详细设计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#swift-name-属性"><span class="nav-number">1.17.4.1.</span> <span class="nav-text">swift_name 属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自动启发式推断"><span class="nav-number">1.17.4.2.</span> <span class="nav-text">自动启发式推断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#底层设施"><span class="nav-number">1.17.4.3.</span> <span class="nav-text">底层设施</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#迁移"><span class="nav-number">1.17.4.4.</span> <span class="nav-text">迁移</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在包括首个标签的所有参数中，建立的统一标签行为"><span class="nav-number">1.18.</span> <span class="nav-text">在包括首个标签的所有参数中，建立的统一标签行为</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对存在代码的影响-1"><span class="nav-number">1.18.1.</span> <span class="nav-text">对存在代码的影响</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#默认情况下，没有使用非空返回函数的返回值，会受到警告"><span class="nav-number">1.19.</span> <span class="nav-text">默认情况下，没有使用非空返回函数的返回值，会受到警告</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍-8"><span class="nav-number">1.19.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可接受笔记"><span class="nav-number">1.19.2.</span> <span class="nav-text">可接受笔记</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#详细设计-6"><span class="nav-number">1.19.3.</span> <span class="nav-text">详细设计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#普遍类型化名"><span class="nav-number">1.20.</span> <span class="nav-text">普遍类型化名</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍-9"><span class="nav-number">1.20.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动机-5"><span class="nav-number">1.20.2.</span> <span class="nav-text">动机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建议的解决方案"><span class="nav-number">1.20.3.</span> <span class="nav-text">建议的解决方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#移动-noescape-和-autoclosure-成类型属性"><span class="nav-number">1.21.</span> <span class="nav-text">移动 @noescape 和 @autoclosure 成类型属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍-10"><span class="nav-number">1.21.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建议解决"><span class="nav-number">1.21.2.</span> <span class="nav-text">建议解决</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除函数参数中let的使用"><span class="nav-number">1.22.</span> <span class="nav-text">删除函数参数中let的使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#废除ImplicitlyUnwrappedOptional（隐式解包可选类型）类型"><span class="nav-number">1.23.</span> <span class="nav-text">废除ImplicitlyUnwrappedOptional（隐式解包可选类型）类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍-11"><span class="nav-number">1.23.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动机-6"><span class="nav-number">1.23.2.</span> <span class="nav-text">动机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#建议的解决方法"><span class="nav-number">1.23.3.</span> <span class="nav-text">建议的解决方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#例子"><span class="nav-number">1.23.4.</span> <span class="nav-text">例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对现有代码的影响"><span class="nav-number">1.23.5.</span> <span class="nav-text">对现有代码的影响</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不安全可能为空的指针明确使用可选的"><span class="nav-number">1.24.</span> <span class="nav-text">不安全可能为空的指针明确使用可选的</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍-12"><span class="nav-number">1.24.1.</span> <span class="nav-text">介绍</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考资料"><span class="nav-number">2.</span> <span class="nav-text">参考资料</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">WillToSky</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  


  




<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"willtosky"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  
  

  

  

</body>
</html>
